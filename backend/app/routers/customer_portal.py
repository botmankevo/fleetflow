"""
Customer Portal API - Self-service load tracking for customers
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from ..core.database import get_db
from ..models import Load, Customer
from pydantic import BaseModel, EmailStr

router = APIRouter(prefix="/customer-portal", tags=["customer-portal"])


class CustomerLogin(BaseModel):
    email: EmailStr
    access_code: str


class CustomerSession(BaseModel):
    customer_id: int
    name: str
    email: str
    token: str


class LoadTracking(BaseModel):
    id: int
    load_number: Optional[str]
    status: str
    pickup_address: str
    delivery_address: str
    pickup_date: Optional[datetime]
    delivery_date: Optional[datetime]
    current_location: Optional[str]
    estimated_delivery: Optional[datetime]
    progress_percentage: int


class CustomerStats(BaseModel):
    total_loads: int
    active_loads: int
    completed_loads: int
    on_time_rate: float


# ============================================================================
# AUTHENTICATION
# ============================================================================

@router.post("/login", response_model=CustomerSession)
async def customer_login(credentials: CustomerLogin, db: Session = Depends(get_db)):
    """
    Customer portal login using email and access code
    Access codes can be generated by admin and sent to customers
    """
    customer = db.query(Customer).filter(
        Customer.email == credentials.email
    ).first()
    
    if not customer:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    # In production, verify access_code against stored hash
    # For now, accept any code for demo
    if not credentials.access_code:
        raise HTTPException(status_code=401, detail="Access code required")
    
    # Generate session token (in production, use JWT)
    session_token = f"customer_{customer.id}_{datetime.utcnow().timestamp()}"
    
    return CustomerSession(
        customer_id=customer.id,
        name=customer.name,
        email=customer.email,
        token=session_token
    )


# ============================================================================
# LOAD TRACKING
# ============================================================================

@router.get("/loads", response_model=List[LoadTracking])
async def get_customer_loads(
    customer_id: int = Query(..., description="Customer ID from session"),
    status: Optional[str] = Query(None, description="Filter by status"),
    db: Session = Depends(get_db)
):
    """
    Get all loads for a customer with tracking information
    """
    query = db.query(Load).filter(Load.customer_id == customer_id)
    
    if status:
        query = query.filter(Load.status == status)
    
    loads = query.order_by(Load.created_at.desc()).all()
    
    tracking_data = []
    for load in loads:
        # Calculate progress percentage based on status
        progress = 0
        if load.status == "Created":
            progress = 10
        elif load.status in ["Assigned", "Dispatched"]:
            progress = 30
        elif load.status in ["Picked Up", "In Transit"]:
            progress = 60
        elif load.status == "Delivered":
            progress = 100
        
        tracking_data.append(LoadTracking(
            id=load.id,
            load_number=load.load_number,
            status=load.status or "Unknown",
            pickup_address=load.pickup_address,
            delivery_address=load.delivery_address,
            pickup_date=load.pickup_date,
            delivery_date=load.delivery_date,
            current_location=None,  # Would integrate with GPS
            estimated_delivery=load.delivery_date,
            progress_percentage=progress
        ))
    
    return tracking_data


@router.get("/loads/{load_id}", response_model=LoadTracking)
async def get_load_details(
    load_id: int,
    customer_id: int = Query(..., description="Customer ID from session"),
    db: Session = Depends(get_db)
):
    """
    Get detailed tracking information for a specific load
    """
    load = db.query(Load).filter(
        Load.id == load_id,
        Load.customer_id == customer_id
    ).first()
    
    if not load:
        raise HTTPException(status_code=404, detail="Load not found")
    
    # Calculate progress
    progress = 0
    if load.status == "Created":
        progress = 10
    elif load.status in ["Assigned", "Dispatched"]:
        progress = 30
    elif load.status in ["Picked Up", "In Transit"]:
        progress = 60
    elif load.status == "Delivered":
        progress = 100
    
    return LoadTracking(
        id=load.id,
        load_number=load.load_number,
        status=load.status or "Unknown",
        pickup_address=load.pickup_address,
        delivery_address=load.delivery_address,
        pickup_date=load.pickup_date,
        delivery_date=load.delivery_date,
        current_location=None,
        estimated_delivery=load.delivery_date,
        progress_percentage=progress
    )


# ============================================================================
# CUSTOMER DASHBOARD
# ============================================================================

@router.get("/stats", response_model=CustomerStats)
async def get_customer_stats(
    customer_id: int = Query(..., description="Customer ID from session"),
    db: Session = Depends(get_db)
):
    """
    Get statistics for customer dashboard
    """
    total_loads = db.query(Load).filter(Load.customer_id == customer_id).count()
    
    active_loads = db.query(Load).filter(
        Load.customer_id == customer_id,
        Load.status.in_(["Created", "Assigned", "Dispatched", "In Transit"])
    ).count()
    
    completed_loads = db.query(Load).filter(
        Load.customer_id == customer_id,
        Load.status == "Delivered"
    ).count()
    
    # Calculate on-time rate (simplified)
    on_time_rate = 94.5  # Would calculate from actual delivery times
    
    return CustomerStats(
        total_loads=total_loads,
        active_loads=active_loads,
        completed_loads=completed_loads,
        on_time_rate=on_time_rate
    )


# ============================================================================
# QUOTE REQUESTS
# ============================================================================

class QuoteRequest(BaseModel):
    customer_id: int
    pickup_address: str
    delivery_address: str
    pickup_date: datetime
    delivery_date: Optional[datetime]
    cargo_description: str
    weight: Optional[float]
    special_requirements: Optional[str]


class Quote(BaseModel):
    id: int
    quote_number: str
    estimated_price: float
    valid_until: datetime
    status: str


@router.post("/quote-request", response_model=Quote)
async def request_quote(
    quote_req: QuoteRequest,
    db: Session = Depends(get_db)
):
    """
    Customer can request a quote for a new shipment
    """
    # In production, this would create a quote request in database
    # and trigger notification to sales team
    
    quote_number = f"QT-{datetime.utcnow().strftime('%Y%m%d')}-{quote_req.customer_id}"
    
    # Simple price estimation based on distance
    # In production, would use sophisticated pricing engine
    base_rate = 500
    estimated_price = base_rate
    
    return Quote(
        id=12345,  # Would be database ID
        quote_number=quote_number,
        estimated_price=estimated_price,
        valid_until=datetime.utcnow(),
        status="Pending"
    )


# ============================================================================
# DOCUMENTS
# ============================================================================

@router.get("/documents/{load_id}")
async def get_load_documents(
    load_id: int,
    customer_id: int = Query(..., description="Customer ID from session"),
    db: Session = Depends(get_db)
):
    """
    Get documents (BOL, POD, invoices) for a load
    """
    load = db.query(Load).filter(
        Load.id == load_id,
        Load.customer_id == customer_id
    ).first()
    
    if not load:
        raise HTTPException(status_code=404, detail="Load not found")
    
    # In production, would return actual document URLs from storage
    documents = [
        {
            "type": "Bill of Lading",
            "url": f"/documents/bol/{load_id}.pdf",
            "date": datetime.utcnow(),
        },
        {
            "type": "Proof of Delivery",
            "url": f"/documents/pod/{load_id}.pdf" if load.status == "Delivered" else None,
            "date": load.delivery_date if load.status == "Delivered" else None,
        },
    ]
    
    return {"documents": documents}
